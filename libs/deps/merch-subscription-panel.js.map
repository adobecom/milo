{
  "version": 3,
  "sources": ["../src/merch-subscription-panel.js", "../../../node_modules/@spectrum-web-components/reactive-controllers/src/FocusGroup.ts", "../../../node_modules/@spectrum-web-components/reactive-controllers/src/RovingTabindex.ts", "../src/constants.js", "../src/utils.js", "../src/async-control.js", "../src/commerce-aware.js", "../src/merch-subscription-panel.css.js", "../src/merch-secure-transaction.js", "../src/merch-secure-transaction.css.js"],
  "sourcesContent": ["import { LitElement, html, nothing } from 'lit';\nimport { RovingTabindexController } from '@spectrum-web-components/reactive-controllers';\n\nimport { CommerceAware } from './commerce-aware.js';\nimport { CLASS_NAME_HIDDEN } from './constants.js';\nimport { isRegularPrice, showOffers } from './utils.js';\nimport { styles } from './merch-subscription-panel.css.js';\nimport './merch-secure-transaction.js';\n\nexport const SLOT_COMMITMENT = 'commitment';\nexport const SLOT_CONDITION = 'condition';\nexport const SLOT_CONDITION_TOOLTIP = 'condition-tooltip';\nexport const SLOT_FOOTER = 'footer';\nexport const SLOT_HEADER = 'header';\nexport const SLOT_OFFER = 'offer';\nexport const SLOT_STOCK = 'stock';\n\nexport const OFFER_SLOTS = [\n    SLOT_COMMITMENT,\n    SLOT_CONDITION,\n    SLOT_CONDITION_TOOLTIP,\n];\n\n/**\n * Update of these properties transfers panel to the \"pending\" state\n */\nconst REACTIONS = ['card', 'checkout', 'commerce', 'offers', 'selected'];\n\nconst TAG_NAME = 'merch-subscription-panel';\nconst TAG_NAME_STOCK = 'merch-stock';\n\nexport class SubscriptionPanel extends CommerceAware(LitElement, TAG_NAME) {\n    /**\n     * Helps to track exact monent when the panel activates.\n     * It requires many factors to meet:\n     *  - commerce servce is active,\n     *  - checkout CTA is provided,\n     *  - some `merch-card` is found and connected,\n     *  - card prices are grouped into offers,\n     *  - global `merch-stock` element is found and connected.\n     */\n    #active = false;\n    /**\n     * Merch card element, currently connected to this panel.\n     * @type { Element | undefined}\n     */\n    #card;\n    /**\n     * Checkout link element, expected to be provided by the consumer.\n     * The panel updates its href for the selected offer.\n     * @type {Commerce.Checkout.Placeholder | undefined}\n     */\n    #checkout;\n    #rovingTabindex = new RovingTabindexController(this, {\n        direction: 'vertical',\n        // @ts-ignore\n        elements: () => [\n            ...this.shadowRoot.querySelectorAll('input[type=\"radio\"]'),\n        ],\n        listenerScope: () => this.shadowRoot.querySelector('#offers'),\n    });\n    /** @type {import('./merch-stock.js').Stock | undefined} */\n    #stock;\n    /**\n     * The stock element discovered at the moment of activation, if any.\n     * @type {boolean}\n     */\n    #stockSelected;\n\n    /**\n     * Updates checkout CTA with the data from the selected offer\n     * so the click on the link will navigate the user to the correct checkout page.\n     */\n    async #updateCheckout() {\n        const { checkout, selected } = this;\n        if (!checkout) return;\n        checkout.classList.toggle(CLASS_NAME_HIDDEN, !selected);\n        if (!selected) return;\n        const { options } = selected.inlinePrices.find(isRegularPrice);\n        if (this.#stockSelected) {\n            const stock = this.#stock;\n            await stock.resolveComplete;\n            const regularPrice =\n                stock.selected.inlinePrices.find(isRegularPrice);\n            checkout.updateOptions({\n                ...options,\n                wcsOsi: options.wcsOsi.concat(\n                    regularPrice?.options?.wcsOsi ?? []\n                ),\n            });\n        } else {\n            checkout.updateOptions(options);\n        }\n        this.control.resolve(checkout.onceSettled());\n    }\n\n    /**\n     * Reacts to selection change and updates offer radios and card prices.\n     */\n    #updateSelected() {\n        const { selected } = this;\n        if (selected) {\n            const radio = this.shadowRoot.getElementById(selected.planType);\n            radio.checked = true;\n            /** @type {import('./merch-stock.js').Stock} */\n            const stock = this.getElementsByTagName(TAG_NAME_STOCK)[0];\n            if (stock) stock.selected = selected;\n            showOffers(this.offers, (offer) => offer === selected);\n        } else {\n            this.selected = this.offers?.values().next().value;\n        }\n    }\n\n    /**\n     * Reacts to update of offers collection and updates slots for literals with the provided content:\n     * - commitment text,\n     * - condition text,\n     * - condition tooltip.\n     */\n    #updateOffers() {\n        const { offers } = this;\n        if (!offers) {\n            this.selected = undefined;\n            return;\n        }\n        this.selected = this.offers.values().next().value;\n        showOffers(offers, (_, index) => index === 0);\n        for (const offer of offers.values()) {\n            /** @type {HTMLTemplateElement} */\n            const template = this.querySelector(\n                `template[name=\"${offer.planType}\"]`\n            );\n            if (template) {\n                OFFER_SLOTS.forEach((slotName) => {\n                    this.#updateSlot(\n                        `${offer.planType}-${slotName}`,\n                        template.content.querySelectorAll(\n                            `[slot=\"${slotName}\"]`\n                        ),\n                        true\n                    );\n                });\n            }\n            const container = offer.container?.cloneNode(true);\n            if (!container) continue;\n            container.classList.remove(CLASS_NAME_HIDDEN);\n            this.#updateSlot(`${offer.planType}-${SLOT_OFFER}`, [container]);\n        }\n    }\n\n    /**\n     * Updates given slot by its `name` by assigning given `elements` to it.\n     * @param { string } name\n     * @param { NodeList | Element[] } elements\n     * @param { boolean } clone\n     * If set to `true`, clones the `elements` before appending them.\n     */\n    #updateSlot(name, elements, clone = false) {\n        this.querySelectorAll(`[slot=\"${name}\"]`).forEach((element) =>\n            element.remove()\n        );\n        elements.forEach((element) => {\n            if (!element) return;\n            if (clone) element = element.cloneNode(true);\n            element.slot = name;\n            this.appendChild(element);\n        });\n    }\n\n    /**\n     * Returns card component, currently connected to this panel.\n     */\n    get card() {\n        return this.#card;\n    }\n\n    /**\n     * Connects given card component to this panel.\n     */\n    set card(card) {\n        if (this.#card === card) return;\n        this.#card = card;\n        this.offers?.clear();\n        this.selected = undefined;\n        if (!card) return;\n        this.log?.debug('Bound to card:', { card, element: this });\n        this.discoverOffers(card);\n    }\n\n    /**\n     * Returns checkout CTA component, controlled by this panel.\n     */\n    get checkout() {\n        return this.#checkout;\n    }\n\n    /**\n     * Returns currently selected stock offer.\n     */\n    get stock() {\n        return this.#stockSelected ? this.#stock : undefined;\n    }\n\n    /**\n     * Selects or deselects stock offer.\n     * @param {boolean} value\n     */\n    set stock(value) {\n        this.#stockSelected = !!value;\n    }\n\n    /**\n     * Renders section with the list of selectable offers,\n     * based on the placeholders and related content found of the connected card.\n     */\n    get offersSection() {\n        const offers = [];\n        for (const { planType } of this.offers.values()) {\n            if (!this.querySelector(`template[name=\"${planType}\"]`)) continue;\n            const onInputChange = () => {\n                this.selected = planType;\n            };\n            const offer = html`<div>\n                <input\n                    autocomplete=\"off\"\n                    ?checked=\"${this.selected?.planType === planType}\"\n                    @change=\"${onInputChange}\"\n                    id=\"${planType}\"\n                    name=\"offer\"\n                    type=\"radio\"\n                    value=\"${planType}\"\n                />\n                <label for=\"${planType}\">\n                    <slot name=\"${planType}-${SLOT_COMMITMENT}\"></slot>\n                    <slot name=\"${planType}-${SLOT_OFFER}\"></slot>\n                    <slot name=\"${planType}-${SLOT_CONDITION}\"></slot>\n                    <overlay-trigger placement=\"top\" offset=\"4\">\n                        <span class=\"condition-icon\" slot=\"trigger\"></span>\n                        <sp-tooltip slot=\"hover-content\" delayed\n                            ><slot\n                                name=\"${planType}-${SLOT_CONDITION_TOOLTIP}\"\n                            ></slot\n                        ></sp-tooltip>\n                    </overlay-trigger>\n                </label>\n            </div> `;\n            offers.push(offer);\n        }\n        return offers;\n    }\n\n    /**\n     * Renderes stock checkbox and stock label, if any `merch-stock` component is found in the DOM.\n     */\n    get stockSection() {\n        /** @type {import('./merch-stock.js').Stock} */\n        const stock = this.#stock;\n        // Stock offers can be filtered out if this panel itself currently displays stocks\n        if (!stock?.offers.size) return nothing;\n        const onStockClick = () => {\n            const old = this.stock;\n            this.stock = !old;\n            this.log?.debug('Stock:', { stock: this.stock, element: this });\n            this.requestUpdate('stock', old);\n        };\n        return html`<sp-field-group>\n            <sp-checkbox\n                ?checked=${!!this.#stockSelected}\n                size=\"m\"\n                @click=${onStockClick}\n            >\n                <slot name=\"${SLOT_STOCK}\"></slot>\n            </sp-checkbox>\n        </sp-field-group>`;\n    }\n\n    /**\n     * Renders subscription layout when connected to a card and has prices.\n     */\n    get listLayout() {\n        const onFooterSlotChange = () => {\n            /** @type { Commerce.Checkout.Placeholder } */\n            /** @type { HTMLSlotElement } */\n            const slot = this.shadowRoot.querySelector(\n                `slot[name=\"${SLOT_FOOTER}\"]`\n            );\n            if (slot) {\n                const checkout = slot\n                    .assignedElements({ flatten: true })\n                    .filter((element) => element.isCheckoutLink)[0];\n                if (this.#checkout !== checkout) {\n                    this.#checkout = checkout;\n                    this.requestUpdate('checkout');\n                }\n            }\n        };\n        return html`\n            <div id=\"panel\">\n                <div id=\"header\" tabindex=\"0\">\n                    <slot name=\"${SLOT_HEADER}\"></slot>\n                </div>\n                <div id=\"offers\">${this.offersSection}</div>\n                <div id=\"stock\">${this.stockSection}</div>\n                <div id=\"footer\">\n                    <slot\n                        name=\"${SLOT_FOOTER}\"\n                        @slotchange=${onFooterSlotChange}\n                    ></slot>\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Renders loading spinner when disconnected from a card or waits for prices to resolve.\n     */\n    get waitLayout() {\n        return html`\n            <sp-theme theme=\"spectrum\" color=\"light\" scale=\"medium\">\n                <div id=\"spinner\">\n                    <sp-progress-circle indeterminate size=\"l\" />\n                </div>\n            </sp-theme>\n        `;\n    }\n\n    /**\n     * @param {Commerce.Offer} offer\n     */\n    filterOffer(offer) {\n        return offer.inlinePrices.some(isRegularPrice);\n    }\n\n    render() {\n        return this.card && this.offers ? this.listLayout : this.waitLayout;\n    }\n\n    /**\n     * Reacts to updates of this component.\n     * @param {Map<string, any>} changed\n     */\n    updated(changed) {\n        const element = this;\n        const { card, checkout, commerce, log, offers } = this;\n        // Log what was updated\n        if (\n            changed.has('card') ||\n            changed.has('checkout') ||\n            changed.has('commerce') ||\n            changed.has('offers')\n        ) {\n            /* c8 ignore start */\n            if (card && checkout && commerce && offers && !this.#active) {\n                /** @type {import('./merch-stock.js').Stock} */\n                const stock = document\n                    .querySelector(TAG_NAME_STOCK)\n                    ?.cloneNode(true);\n                if (stock) {\n                    stock.selected = this.selected;\n                    this.#stock = stock;\n                }\n                this.#updateSlot(SLOT_STOCK, [stock]);\n                this.#active = true;\n                log.debug('Activated:', {\n                    card,\n                    offers,\n                    checkout,\n                    element,\n                    stock,\n                });\n            } else {\n                // Note: Lazy logging pattern\n                // The costly computing of changed props will only run if debug logs are not filtered out by env config\n                log?.debug('Updated:', () => ({\n                    ...Object.fromEntries(\n                        [...changed.entries()].map(([key, old]) => [\n                            key,\n                            { new: this[key], old },\n                        ])\n                    ),\n                    element,\n                }));\n            }\n            /* c8 ignore stop */\n            if (this.#active && !(card && checkout && offers)) {\n                this.#active = false;\n            }\n        }\n        // Updated offers collection\n        if (changed.has('offers')) {\n            this.#updateOffers();\n        }\n        // Updated offer selection\n        if (changed.has('selected')) {\n            this.#updateSelected();\n            this.#updateCheckout();\n        }\n        // Updated checkout CTA in the footer slot\n        if (changed.has('checkout') || changed.has('stock')) {\n            this.#updateCheckout();\n        }\n    }\n\n    requestUpdate(name, ...args) {\n        super.requestUpdate(name, ...args);\n        if (this.isUpdatePending && REACTIONS.includes(name))\n            // Any update to any custom reactive property transfers this component to the pending state\n            // so to perform discovery and async resolution of placeholders from the bound card,\n            // stock offers from the document nearby, group everything and render\n            this.control.init();\n    }\n\n    static styles = [styles];\n}\n\nwindow.customElements.define(TAG_NAME, SubscriptionPanel);\n", "/*\nCopyright 2020 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport type { ReactiveController, ReactiveElement } from 'lit';\n\ntype DirectionTypes = 'horizontal' | 'vertical' | 'both' | 'grid';\nexport type FocusGroupConfig<T> = {\n    focusInIndex?: (_elements: T[]) => number;\n    direction?: DirectionTypes | (() => DirectionTypes);\n    elementEnterAction?: (el: T) => void;\n    elements: () => T[];\n    isFocusableElement?: (el: T) => boolean;\n    listenerScope?: HTMLElement | (() => HTMLElement);\n};\n\nfunction ensureMethod<T, RT>(\n    value: T | RT | undefined,\n    type: string,\n    fallback: T\n): T {\n    if (typeof value === type) {\n        return (() => value) as T;\n    } else if (typeof value === 'function') {\n        return value as T;\n    }\n    return fallback;\n}\n\nexport class FocusGroupController<T extends HTMLElement>\n    implements ReactiveController\n{\n    protected cachedElements?: T[];\n    private mutationObserver: MutationObserver;\n\n    get currentIndex(): number {\n        if (this._currentIndex === -1) {\n            this._currentIndex = this.focusInIndex;\n        }\n        return this._currentIndex - this.offset;\n    }\n\n    set currentIndex(currentIndex) {\n        this._currentIndex = currentIndex + this.offset;\n    }\n\n    private _currentIndex = -1;\n\n    get direction(): DirectionTypes {\n        return this._direction();\n    }\n\n    _direction = (): DirectionTypes => 'both';\n\n    public directionLength = 5;\n\n    elementEnterAction = (_el: T): void => {\n        return;\n    };\n\n    get elements(): T[] {\n        if (!this.cachedElements) {\n            this.cachedElements = this._elements();\n        }\n        return this.cachedElements;\n    }\n\n    private _elements!: () => T[];\n\n    protected set focused(focused: boolean) {\n        /* c8 ignore next 1 */\n        if (focused === this.focused) return;\n        this._focused = focused;\n    }\n\n    protected get focused(): boolean {\n        return this._focused;\n    }\n\n    private _focused = false;\n\n    get focusInElement(): T {\n        return this.elements[this.focusInIndex];\n    }\n\n    get focusInIndex(): number {\n        return this._focusInIndex(this.elements);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _focusInIndex = (_elements: T[]): number => 0;\n\n    host: ReactiveElement;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isFocusableElement = (_el: T): boolean => true;\n\n    isEventWithinListenerScope(event: Event): boolean {\n        if (this._listenerScope() === this.host) return true;\n        return event.composedPath().includes(this._listenerScope());\n    }\n\n    _listenerScope = (): HTMLElement => this.host;\n\n    // When elements are virtualized, the delta between the first element\n    // and the first rendered element.\n    offset = 0;\n\n    recentlyConnected = false;\n\n    constructor(\n        host: ReactiveElement,\n        {\n            direction,\n            elementEnterAction,\n            elements,\n            focusInIndex,\n            isFocusableElement,\n            listenerScope,\n        }: FocusGroupConfig<T> = { elements: () => [] }\n    ) {\n        this.mutationObserver = new MutationObserver(() => {\n            this.handleItemMutation();\n        });\n        this.host = host;\n        this.host.addController(this);\n        this._elements = elements;\n        this.isFocusableElement = isFocusableElement || this.isFocusableElement;\n        this._direction = ensureMethod<() => DirectionTypes, DirectionTypes>(\n            direction,\n            'string',\n            this._direction\n        );\n        this.elementEnterAction = elementEnterAction || this.elementEnterAction;\n        this._focusInIndex = ensureMethod<(_elements: T[]) => number, number>(\n            focusInIndex,\n            'number',\n            this._focusInIndex\n        );\n        this._listenerScope = ensureMethod<() => HTMLElement, HTMLElement>(\n            listenerScope,\n            'object',\n            this._listenerScope\n        );\n    }\n    /*  In  handleItemMutation() method the first if condition is checking if the element is not focused or if the element's children's length is not decreasing then it means no element has been deleted and we must return.\n        Then we are checking if the deleted element was the focused one before the deletion if so then we need to proceed else we casn return;\n    */\n    handleItemMutation(): void {\n        if (\n            this._currentIndex == -1 ||\n            this.elements.length <= this._elements().length\n        )\n            return;\n        const focusedElement = this.elements[this.currentIndex];\n        this.clearElementCache();\n        if (this.elements.includes(focusedElement)) return;\n        const moveToNextElement = this.currentIndex !== this.elements.length;\n        const diff = moveToNextElement ? 1 : -1;\n        if (moveToNextElement) {\n            this.setCurrentIndexCircularly(-1);\n        }\n        this.setCurrentIndexCircularly(diff);\n        this.focus();\n    }\n\n    update({ elements }: FocusGroupConfig<T> = { elements: () => [] }): void {\n        this.unmanage();\n        this._elements = elements;\n        this.clearElementCache();\n        this.manage();\n    }\n\n    focus(options?: FocusOptions): void {\n        const elements = this.elements;\n        if (!elements.length) return;\n        let focusElement = elements[this.currentIndex];\n        if (!focusElement || !this.isFocusableElement(focusElement)) {\n            this.setCurrentIndexCircularly(1);\n            focusElement = elements[this.currentIndex];\n        }\n        if (focusElement && this.isFocusableElement(focusElement)) {\n            focusElement.focus(options);\n        }\n    }\n\n    clearElementCache(offset = 0): void {\n        this.mutationObserver.disconnect();\n        delete this.cachedElements;\n        this.offset = offset;\n        requestAnimationFrame(() => {\n            this.elements.forEach((element) => {\n                this.mutationObserver.observe(element, {\n                    attributes: true,\n                });\n            });\n        });\n    }\n\n    setCurrentIndexCircularly(diff: number): void {\n        const { length } = this.elements;\n        let steps = length;\n        // start at a possibly not 0 index\n        let nextIndex = (length + this.currentIndex + diff) % length;\n        while (\n            // don't cycle the elements more than once\n            steps &&\n            this.elements[nextIndex] &&\n            !this.isFocusableElement(this.elements[nextIndex])\n        ) {\n            nextIndex = (length + nextIndex + diff) % length;\n            steps -= 1;\n        }\n        this.currentIndex = nextIndex;\n    }\n\n    hostContainsFocus(): void {\n        this.host.addEventListener('focusout', this.handleFocusout);\n        this.host.addEventListener('keydown', this.handleKeydown);\n        this.focused = true;\n    }\n\n    hostNoLongerContainsFocus(): void {\n        this.host.addEventListener('focusin', this.handleFocusin);\n        this.host.removeEventListener('focusout', this.handleFocusout);\n        this.host.removeEventListener('keydown', this.handleKeydown);\n        this.focused = false;\n    }\n\n    isRelatedTargetAnElement(event: FocusEvent): boolean {\n        const relatedTarget = event.relatedTarget as null | Element;\n        return !this.elements.includes(relatedTarget as T);\n    }\n\n    handleFocusin = (event: FocusEvent): void => {\n        if (!this.isEventWithinListenerScope(event)) return;\n        if (this.isRelatedTargetAnElement(event)) {\n            this.hostContainsFocus();\n        }\n        const path = event.composedPath() as T[];\n        let targetIndex = -1;\n        path.find((el) => {\n            targetIndex = this.elements.indexOf(el);\n            return targetIndex !== -1;\n        });\n        this.currentIndex = targetIndex > -1 ? targetIndex : this.currentIndex;\n    };\n\n    handleFocusout = (event: FocusEvent): void => {\n        if (this.isRelatedTargetAnElement(event)) {\n            this.hostNoLongerContainsFocus();\n        }\n    };\n\n    acceptsEventCode(code: string): boolean {\n        if (code === 'End' || code === 'Home') {\n            return true;\n        }\n        switch (this.direction) {\n            case 'horizontal':\n                return code === 'ArrowLeft' || code === 'ArrowRight';\n            case 'vertical':\n                return code === 'ArrowUp' || code === 'ArrowDown';\n            case 'both':\n            case 'grid':\n                return code.startsWith('Arrow');\n        }\n    }\n\n    handleKeydown = (event: KeyboardEvent): void => {\n        if (!this.acceptsEventCode(event.code) || event.defaultPrevented) {\n            return;\n        }\n        let diff = 0;\n        switch (event.code) {\n            case 'ArrowRight':\n                diff += 1;\n                break;\n            case 'ArrowDown':\n                diff += this.direction === 'grid' ? this.directionLength : 1;\n                break;\n            case 'ArrowLeft':\n                diff -= 1;\n                break;\n            case 'ArrowUp':\n                diff -= this.direction === 'grid' ? this.directionLength : 1;\n                break;\n            case 'End':\n                this.currentIndex = 0;\n                diff -= 1;\n                break;\n            case 'Home':\n                this.currentIndex = this.elements.length - 1;\n                diff += 1;\n                break;\n        }\n        event.preventDefault();\n        if (this.direction === 'grid' && this.currentIndex + diff < 0) {\n            this.currentIndex = 0;\n        } else if (\n            this.direction === 'grid' &&\n            this.currentIndex + diff > this.elements.length - 1\n        ) {\n            this.currentIndex = this.elements.length - 1;\n        } else {\n            this.setCurrentIndexCircularly(diff);\n        }\n        // To allow the `focusInIndex` to be calculated with the \"after\" state of the keyboard interaction\n        // do `elementEnterAction` _before_ focusing the next element.\n        this.elementEnterAction(this.elements[this.currentIndex]);\n        this.focus();\n    };\n\n    manage(): void {\n        this.addEventListeners();\n    }\n\n    unmanage(): void {\n        this.removeEventListeners();\n    }\n\n    addEventListeners(): void {\n        this.host.addEventListener('focusin', this.handleFocusin);\n    }\n\n    removeEventListeners(): void {\n        this.host.removeEventListener('focusin', this.handleFocusin);\n        this.host.removeEventListener('focusout', this.handleFocusout);\n        this.host.removeEventListener('keydown', this.handleKeydown);\n    }\n\n    hostConnected(): void {\n        this.recentlyConnected = true;\n        this.addEventListeners();\n    }\n\n    hostDisconnected(): void {\n        this.mutationObserver.disconnect();\n        this.removeEventListeners();\n    }\n\n    hostUpdated(): void {\n        if (this.recentlyConnected) {\n            this.recentlyConnected = false;\n            this.elements.forEach((element) => {\n                this.mutationObserver.observe(element, {\n                    attributes: true,\n                });\n            });\n        }\n    }\n}\n", "/*\nCopyright 2020 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport { FocusGroupConfig, FocusGroupController } from './FocusGroup.js';\n\nexport type RovingTabindexConfig<T> = FocusGroupConfig<T>;\ninterface UpdateTabIndexes {\n    tabIndex: number;\n    removeTabIndex?: boolean;\n}\n\nexport class RovingTabindexController<\n    T extends HTMLElement\n> extends FocusGroupController<T> {\n    protected override set focused(focused: boolean) {\n        if (focused === this.focused) return;\n        super.focused = focused;\n        this.manageTabindexes();\n    }\n\n    protected override get focused(): boolean {\n        return super.focused;\n    }\n\n    private managed = true;\n\n    private manageIndexesAnimationFrame = 0;\n\n    override clearElementCache(offset = 0): void {\n        cancelAnimationFrame(this.manageIndexesAnimationFrame);\n        super.clearElementCache(offset);\n        if (!this.managed) return;\n\n        this.manageIndexesAnimationFrame = requestAnimationFrame(() =>\n            this.manageTabindexes()\n        );\n    }\n\n    manageTabindexes(): void {\n        if (this.focused) {\n            this.updateTabindexes(() => ({ tabIndex: -1 }));\n        } else {\n            this.updateTabindexes((el: HTMLElement): UpdateTabIndexes => {\n                return {\n                    removeTabIndex:\n                        el.contains(this.focusInElement) &&\n                        el !== this.focusInElement,\n                    tabIndex: el === this.focusInElement ? 0 : -1,\n                };\n            });\n        }\n    }\n\n    updateTabindexes(getTabIndex: (el: HTMLElement) => UpdateTabIndexes): void {\n        this.elements.forEach((el) => {\n            const { tabIndex, removeTabIndex } = getTabIndex(el);\n            if (!removeTabIndex) {\n                el.tabIndex = tabIndex;\n                return;\n            }\n            el.removeAttribute('tabindex');\n            const updatable = el as unknown as {\n                requestUpdate?: () => void;\n            };\n            if (updatable.requestUpdate) updatable.requestUpdate();\n        });\n    }\n\n    override manage(): void {\n        this.managed = true;\n        this.manageTabindexes();\n        super.manage();\n    }\n\n    override unmanage(): void {\n        this.managed = false;\n        this.updateTabindexes(() => ({ tabIndex: 0 }));\n        super.unmanage();\n    }\n\n    override hostUpdated(): void {\n        super.hostUpdated();\n        if (!this.host.hasUpdated) {\n            this.manageTabindexes();\n        }\n    }\n}\n", "/**\n * Common namespace prefix for CSS classes and DOM event types.\n * @see https://git.corp.adobe.com/wcms/team/discussions/27\n */\nexport const NAMESPACE = 'merch';\n/**\n * This CSS class name is used to:\n * - show only selected offer on a card connected to a subscription panel\n * - TBD\n */\nexport const CLASS_NAME_HIDDEN = 'hidden';\n/**\n * Event type dispatched by the commenrce service whenever it is ready.\n * Should be in sync with `packages/commerce/src/constants.js`.\n */\nexport const EVENT_TYPE_READY = 'wcms:commerce:ready';\n/**\n * Tag name of the commerce service component.\n * Should be in sync with `packages/commerce/src/constants.js`.\n */\nexport const TAG_NAME_SERVICE = 'wcms-commerce';\n", "import { CLASS_NAME_HIDDEN, NAMESPACE } from './constants.js';\n\nexport function debounce(func, delay) {\n    let debounceTimer;\n    return function () {\n        const context = this;\n        const args = arguments;\n        clearTimeout(debounceTimer);\n        debounceTimer = setTimeout(() => func.apply(context, args), delay);\n    };\n}\n\nexport const getSlotText = (element, name) =>\n    element.querySelector(`[slot=\"${name}\"]`).textContent.trim();\n\n/**\n * Dispatches custom event of the given `type` on the given `target`.\n * @template T\n * @param {EventTarget} target\n * @param {string} type\n * @param {CustomEventInit<T>} options\n */\nexport const dispatchAsyncEvent = (\n    target,\n    type,\n    { bubbles = true, cancelable, composed, detail } = {}\n) =>\n    window.setTimeout(() =>\n        target?.dispatchEvent(\n            new CustomEvent(type, {\n                bubbles,\n                cancelable,\n                composed,\n                detail,\n            })\n        )\n    );\n\n/**\n * Finds the closest common ancestor for given array of DOM elements.\n * Note: the search may go up DOM tree beyoud some expected container (e.g. card) and event result in `document.body`.\n * For a good solution, @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n * @param { Element[] } elements\n * Array of DOM elements to find the common ancestor for.\n * @returns { Element | null }\n * The closest common ancestor of the given elements or `null` if none found.\n */\nexport function getCommonAncestor(...elements) {\n    const [first, ...rest] = elements;\n    if (!first) return null;\n    let ancestor = first.parentElement;\n    if (!rest.length) return ancestor;\n    while (ancestor) {\n        if (rest.every((element) => ancestor.contains(element))) {\n            return ancestor;\n        }\n        ancestor = ancestor.parentElement;\n    }\n    return null;\n}\n\n/**\n * @param {Commerce.Placeholder} placeholder\n * @returns {boolean}\n */\nexport function isRegularPrice(placeholder) {\n    if (placeholder.isInlinePrice) {\n        const { template } = placeholder.dataset;\n        if (template === 'price' || !template) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Joins an array of string `tokens`,\n * filtering out `falsy` values and replacing non-word characters in each token.\n * @param { string[] } tokens\n * Array of strings to be joined.\n * @param { string } delimiter\n * Delimiter used to join the tokens and replace non-word characters.\n */\nconst joinTokens = (tokens, delimiter) =>\n    tokens\n        .flatMap((token) => token?.split?.(/\\W+/g))\n        .filter((token, index) => token && (index > 0 || token !== NAMESPACE))\n        .join(delimiter);\n\n/**\n * Creates a namespaced CSS class name.\n * Replaces any sequence of non-word characters with a single hyphen.\n * @param {...string} args - Components of the class name.\n * @returns {string} - The namespaced and cleaned CSS class name.\n */\nexport const makeCssClassName = (...args) =>\n    `${NAMESPACE}-${joinTokens(args, '-')}`;\n\n/**\n * Creates a namespaced event type.\n * Replaces any sequence of non-word characters with a single colon.\n * @param {...string} args - Components of the event type.\n * @returns {string} The namespaced and cleaned event type.\n */\nexport const makeEventTypeName = (...args) =>\n    `${NAMESPACE}:${joinTokens(args, ':')}`;\n\n/**\n * @param {Commerce.Offers} offers\n * @param {Commerce.filterOffer} filter\n */\nexport function showOffers(offers, filter = () => true) {\n    let i = 0;\n    for (const offer of offers.values()) {\n        offer.container?.classList.toggle(\n            CLASS_NAME_HIDDEN,\n            !filter(offer, i++)\n        );\n    }\n}\n", "import {\n    dispatchAsyncEvent,\n    makeCssClassName,\n    makeEventTypeName,\n} from './utils.js';\n\nconst FAILED = 'failed';\nconst PENDING = 'pending';\nconst RESOLVED = 'resolved';\n\n/**\n * Notifies observers about results of asynchronous operations that\n * can be performed by a component from time to time.\n * An async component can be in one of these states:\n * - `pending` - the component is waiting for the async operation to complete;\n * - `resolved` - the async operation has completed successfully;\n * - `failed` - the async operation has failed.\n * This helper toggles state-reflecting CSS classes and emits state events,\n * prefixed for distinguity between various component types.\n */\nexport class AsyncControl {\n    /**\n     * The latest value or error collected from a controlled async operation.\n     * @type {Commerce.EventDetail}\n     */\n    #detail = {};\n    /**\n     * Control options.\n     * @type {{\n     *  cssClassNames?: Record<string, string>;\n     *  eventOptions?: EventInit;\n     *  eventTypeNames?: Record<string, string>;\n     * }}\n     */\n    #options = {};\n    /**\n     * Current state.\n     * @type {string}\n     */\n    #state;\n    /**\n     * The controlled web component.\n     */\n    #target;\n\n    /**\n     * Creates a new instance of control, pending for an async operation.\n     * @param {Element} target - Target element to control.\n     * @param {{\n     *  cssPrefix?: string;\n     *  eventOptions?: EventInit;\n     *  eventPrefix?: string;\n     * }} options - Notification options:\n     * - `cssPrefix`: prepended to the state CSS class names, toggled on the controlled component;\n     * - `eventOptions`: settings for custom events, dispatched by this control;\n     * - `eventPrefix`: prepended to the state event names, dispatched on the controlled component.\n     */\n    constructor(target, { cssPrefix, eventOptions = {}, eventPrefix } = {}) {\n        this.#target = target;\n        const options = this.#options;\n        options.cssClassNames = {};\n        options.eventOptions = eventOptions;\n        options.eventTypeNames = {};\n        for (const state of [FAILED, PENDING, RESOLVED]) {\n            options.cssClassNames[state] = makeCssClassName(cssPrefix, state);\n            options.eventTypeNames[state] = makeEventTypeName(\n                eventPrefix,\n                state\n            );\n        }\n        this.init();\n    }\n\n    /**\n     * Notifies observers about current state of the component by\n     * setting CSS state class and dispatching event.\n     */\n    #notify() {\n        const [\n            detail,\n            { cssClassNames, eventOptions, eventTypeNames },\n            state,\n            target,\n        ] = [this.#detail, this.#options, this.#state, this.#target];\n        [FAILED, PENDING, RESOLVED].forEach((key) => {\n            target.classList.toggle(cssClassNames[key], key === state);\n        });\n        dispatchAsyncEvent(target, eventTypeNames[state], {\n            ...eventOptions,\n            detail,\n        });\n    }\n\n    /**\n     * Gets the latest rejection error.\n     * @returns {Error | undefined}\n     */\n    get error() {\n        return this.#detail.error;\n    }\n\n    get options() {\n        return this.#options;\n    }\n\n    /**\n     * Returns the promise pending for completion of the currently active async operation.\n     * If no operation is active at the moment, returns settled promise.\n     * @returns {Promise}\n     */\n    get promise() {\n        return new Promise((resolve, reject) => {\n            this.subscribe(resolve, reject);\n        });\n    }\n\n    /**\n     * Returns the current state of the object.\n     * @returns {string}\n     */\n    get state() {\n        return this.#state;\n    }\n\n    /**\n     * Signals start of a new asynchronous operation.\n     * @return `false` if this control is already in \"pending\" state, otherwise `true`.\n     */\n    init() {\n        if (this.#state !== PENDING) {\n            this.#state = PENDING;\n            this.#notify();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Signals success of an asynchronous operation and stores its `value`.\n     * @param {Error} error\n     * @return `false` if this control is not in \"pending\" state, otherwise `true`.\n     */\n    reject(error) {\n        if (this.#state !== PENDING) return false;\n        this.#detail.error = error;\n        this.#state = FAILED;\n        this.#notify();\n        return true;\n    }\n\n    /**\n     * Signals  success of the asynchronous operation and stores its `value`.\n     * If provided argument is a promise, waits for its resolution.\n     * @param {any} [value]\n     * @return `false` if this control is not in \"pending\" state, otherwise `true`.\n     */\n    async resolve(value) {\n        if (this.#state !== PENDING) return false;\n        this.#detail.value = value == null ? undefined : await value;\n        this.#state = RESOLVED;\n        this.#notify();\n        return true;\n    }\n\n    /**\n     * Registers the `resolved` and optional `rejected` callbacks\n     * to be notified about state changes.\n     * @param {Commerce.resolved} resolved\n     * @param {Commerce.failed} failed\n     * @param {boolean} once\n     * @return {() => void}\n     */\n    subscribe(resolved, failed = () => {}, once = false) {\n        const [detail, { eventTypeNames }, state, target] = [\n            this.#detail,\n            this.#options,\n            this.#state,\n            this.#target,\n        ];\n        if (RESOLVED === state) {\n            resolved(detail.value, target);\n            return () => {};\n        }\n        if (FAILED === state) {\n            failed?.(detail.error, target);\n            return () => {};\n        }\n        const options = once ? { once: true } : undefined;\n        const onFailed = (event) => failed(detail.error, event.target);\n        const onResolved = (event) => resolved(detail.value, event.target);\n        target.addEventListener(eventTypeNames[FAILED], onFailed, options);\n        target.addEventListener(eventTypeNames[RESOLVED], onResolved, options);\n        return () => {\n            target.removeEventListener(eventTypeNames[FAILED], onFailed);\n            target.removeEventListener(eventTypeNames[RESOLVED], onResolved);\n        };\n    }\n\n    static FAILED = FAILED;\n    static PENDING = PENDING;\n    static RESOLVED = RESOLVED;\n}\n", "import { AsyncControl } from './async-control.js';\nimport { EVENT_TYPE_READY, TAG_NAME_SERVICE } from './constants.js';\nimport { getCommonAncestor } from './utils.js';\n\nexport const UNKNOWN_PLAN_TYPE = 'UNKNOWN';\n\n/**\n * Groups commerce placeholders inside the `conteiner` element\n * into `offer` objects, by their subsription plan type.\n * @param {Commerce.Placeholder[]} placeholders\n * @param {Element} container\n * @param {{\n *  filterOffer?: Commerce.filterOffer;\n *  filterPlaceholder?: Commerce.filterPlaceholder;\n * }} filters\n */\nasync function makeOffers(container, filters, placeholders) {\n    /** @type {Commerce.Offers} */\n    const offers = new Map();\n    // Note: all placeholders are awaited in parallel\n    await Promise.allSettled(\n        placeholders.map((placeholder) => placeholder.onceSettled())\n    );\n    let i = 0;\n    for (const placeholder of placeholders) {\n        if (!filters.filterPlaceholder(placeholder, i++)) continue;\n        const wcsOffers = placeholder?.value ?? [];\n        // Note: `UNKNOWN_PLAN_TYPE` - special group for failed commerce placeholders, perhaps should be ignored in render\n        for (const { planType = UNKNOWN_PLAN_TYPE } of wcsOffers) {\n            // Use group for this plan type, create if needed\n            const group = offers.get(planType) ?? {\n                checkoutLinks: [],\n                inlinePrices: [],\n                planType,\n                get container() {\n                    const { checkoutLinks, inlinePrices } = group;\n                    const candidate = getCommonAncestor(\n                        ...checkoutLinks,\n                        ...inlinePrices\n                    );\n                    if (\n                        candidate?.compareDocumentPosition(container) &\n                        Node.DOCUMENT_POSITION_CONTAINS\n                    ) {\n                        return candidate;\n                    }\n                    return undefined;\n                },\n            };\n            // Classify placeholder\n            if (placeholder.isCheckoutLink) {\n                group.checkoutLinks.push(placeholder);\n            } else if (placeholder.isInlinePrice) {\n                group.inlinePrices.push(placeholder);\n            }\n            offers.set(planType, group);\n        }\n    }\n    i = 0;\n    for (const offer of offers.values()) {\n        if (!filters.filterOffer(offer, i++)) {\n            offers.delete(offer.planType);\n        }\n    }\n    return offers;\n}\n\n/**\n * Notifies the provided `callback` every time the commerce service is initialised,\n * providing currently active instance of the service.\n * @param {(commerce: Commerce.Instance) => void} callback\n * @param {{ once?: boolean; }} options\n * @returns {() => void}\n * A function to unsubscribe from notifications.\n */\nexport function discoverService(callback, { once = false } = {}) {\n    const { head } = document;\n    let latest = null;\n    function discover() {\n        /** @type { Commerce.Instance } */\n        const current = head.querySelector(TAG_NAME_SERVICE);\n        if (current === latest) return;\n        latest = current;\n        if (current) callback(current);\n    }\n    head.addEventListener(EVENT_TYPE_READY, discover, { once });\n    window.setTimeout(discover);\n    return () => head.removeEventListener(EVENT_TYPE_READY, discover);\n}\n\n/**\n * Lit mixin for web components requiring active instance of the commerce service.\n * Creates `commerce`, `log` and `offers` properties on the enhanced component.\n * @param {Commerce.ComponentConstructor} Component - Component constructor.\n * @param {string} tagName - Tag name of the component.\n * @example\n * class MyElement extends CommerceAware(LitElement, 'my-element') {}\n */\nexport function CommerceAware(Component, tagName) {\n    // TODO: `name` arg can be replaced with a call to `CustomElementRegistry.getName` method in the future\n    // SEE: https://caniuse.com/mdn-api_customelementregistry_getname\n    return class CommerceAware extends Component {\n        /**\n         * Notifies connected components about state changes.\n         */\n        #control = new AsyncControl(this, {\n            cssPrefix: tagName,\n            eventPrefix: tagName,\n        });\n        /** @type {Commerce.Instance | undefined} */\n        #commerce;\n        /** @type {() => void} */\n        #dispose;\n        /** @type {Commerce.Log.Instance | undefined} */\n        #log;\n        /** @type {Commerce.Offers | undefined} */\n        #offers;\n        /**\n         * Preselected offer type, if any.\n         * @type { any }\n         */\n        #preselected;\n        /**\n         * The currently selected offer, if any.\n         * @type { Commerce.Offer | undefined }\n         */\n        #selected;\n\n        /**\n         * Sets selected offer and notifies subscribers.\n         * @param { string | Commerce.Offer } value\n         */\n        #updateSelected(value) {\n            const { offers } = this;\n            if (!offers) return;\n            const selected = offers.get(value) ?? offers.get(value?.planType);\n            if (selected === this.#selected) return;\n            const old = this.#selected;\n            this.#selected = selected;\n            this.requestUpdate('selected', old);\n            /* c8 ignore start */\n            this.log?.debug('Selected:', {\n                selected: this.selected?.planType,\n                element: this,\n            });\n            /* c8 ignore stop */\n        }\n\n        /**\n         * Returns the currently active instance of commerce service.\n         */\n        get commerce() {\n            return this.#commerce;\n        }\n\n        /**\n         * Returns an instance of async control class,\n         * used to notify observers abour state changes.\n         */\n        get control() {\n            return this.#control;\n        }\n\n        /**\n         * Returns an instance of logger, associated with this component.\n         */\n        get log() {\n            return this.#log;\n        }\n\n        /**\n         * Returns offers found during the latest call to the `discoverOffers` method,\n         * grouped by their plan type.\n         */\n        get offers() {\n            return this.#offers;\n        }\n\n        /**\n         * Returns a promise resolving when this panel has all data to render the offers,\n         * or rejecting with the error occured during offer resolution.\n         */\n        get resolveComplete() {\n            return this.#control.promise;\n        }\n\n        /**\n         * Returns the currently selected selected offer object, if any.\n         * @returns { Commerce.Offer | undefined }\n         */\n        get selected() {\n            return this.#selected;\n        }\n\n        /**\n         * Allows programmatic control of the selected offer.\n         * Accepts either plan type as a string\n         * or an offer object and uses its plan type to select among known offers.\n         * If the given plan type cannot be found,\n         * selects the first offer,following the document order.\n         * @param { string | Commerce.Offer } value\n         */\n        set selected(value) {\n            this.#preselected = value;\n            this.#updateSelected(value);\n        }\n\n        connectedCallback() {\n            super.connectedCallback();\n            this.#dispose = discoverService((commerce) => {\n                const old = [this.#commerce, this.#log, this.#offers];\n                this.#commerce = commerce;\n                this.#log = commerce.Log.module(tagName);\n                this.#offers = undefined;\n                this.#log.debug('Connected:', { element: this });\n                this.requestUpdate('commerce', old[0]);\n                this.requestUpdate('log', old[1]);\n                this.requestUpdate('offers', old[2]);\n            });\n        }\n\n        disconnectedCallback() {\n            this.#log.debug('Disconnected:', { element: this });\n            super.disconnectedCallback();\n            this.#dispose?.();\n        }\n\n        /**\n         * Overridable method to filter offers discoverable for this component.\n         * By default, accepts all offers.\n         * @param {Commerce.Offer} offer\n         * @param {number} index\n         */\n        filterOffer(offer, index) {\n            return true;\n        }\n\n        /**\n         * Overridable method to filter placeholders discoverable for this component.\n         * By default, accepts all placeholders.\n         * @param {Commerce.Placeholder} placeholder\n         * @param {number} index\n         */\n        filterPlaceholder(placeholder, index) {\n            return true;\n        }\n\n        /**\n         * Finds all commerce placeholders inside the `container` and groups them into offer objects.\n         * A web page offer normally includes `checkout-link` and `inline-price` components\n         * having same plan type and surrounded with some descriptive text.\n         * @param { Element } container\n         */\n        async discoverOffers(container) {\n            this.#control.init();\n            const placeholders = [];\n            const { commerce } = this;\n            if (commerce) {\n                const { CheckoutLink, InlinePrice } = commerce;\n                placeholders.push(\n                    ...CheckoutLink.getCheckoutLinks(container),\n                    ...InlinePrice.getInlinePrices(container)\n                );\n                this.log.debug('Discovering offers:', {\n                    container,\n                    element: this,\n                });\n            }\n            const old = this.#offers;\n            try {\n                const offers = await makeOffers(container, this, placeholders);\n                this.#offers = offers;\n                this.requestUpdate('offers', old);\n                this.#updateSelected(this.#preselected);\n            } catch (error) {\n                this.#control.reject(error);\n            }\n        }\n    };\n}\n", "// TODO: css variables, a11y, r12s ;)\nimport { css } from 'lit';\n\nexport const styles = css`\n    :host {\n        background-color: #f5f5f5;\n        border-radius: var(--consonant-merch-spacing-xs);\n        display: block;\n        padding: var(--consonant-merch-spacing-xs);\n    }\n\n    #footer {\n        justify-content: space-between;\n        display: flex;\n        grid-area: footer;\n        order: 4;\n    }\n    #footer:focus-within {\n        outline: var(--merch-focused-outline);\n        outline-offset: 8px;\n    }\n\n    #header {\n        grid-area: header;\n        order: 1;\n        outline: none;\n        padding: 0 0.25em;\n    }\n    #header:focus-visible {\n        outline: var(--merch-focused-outline);\n        outline-offset: 8px;\n    }\n\n    #offers {\n        grid-area: offers;\n        order: 2;\n    }\n    #offers:focus-within {\n        outline: var(--merch-focused-outline);\n        outline-offset: 8px;\n    }\n\n    #panel {\n        display: grid;\n        gap: var(--consonant-merch-spacing-xs);\n        grid-template-areas:\n            'header'\n            'offers'\n            'stock'\n            'footer';\n    }\n\n    #spinner {\n        display: flex;\n        justify-content: center;\n    }\n\n    #stock {\n        grid-area: stock;\n        order: 3;\n    }\n    #stock:focus-within {\n        outline: var(--merch-focused-outline);\n        outline-offset: 8px;\n    }\n\n    input[type='radio'] {\n        height: 0;\n        outline: none;\n        position: absolute;\n        width: 0;\n        z-index: -1;\n    }\n\n    label {\n        background-color: white;\n        border: 1px solid transparent;\n        border-radius: var(--consonant-merch-spacing-xxxs);\n        cursor: pointer;\n        display: block;\n        margin: var(--consonant-merch-spacing-xs) 0;\n        padding: var(--consonant-merch-spacing-xs);\n        position: relative;\n    }\n\n    label:hover {\n        box-shadow: var(--merch-hovered-shadow);\n    }\n\n    input:checked + label {\n        box-shadow: var(--merch-selected-shadow);\n    }\n\n    .condition-icon {\n        background-position: center;\n        background-size: contain;\n        background: var(--info-icon) no-repeat;\n        content: '';\n        color: #6e6e6e;\n        display: inline-block;\n        height: 1.1em;\n        margin-bottom: -3px;\n        width: 1.1em;\n    }\n\n    ::slotted([slot$='-commitment']) {\n    }\n\n    ::slotted([slot$='-condition']) {\n        display: inline-block;\n        font-style: italic;\n    }\n\n    ::slotted([slot$='-plan']) {\n        font-weight: 700;\n    }\n`;\n", "// NOTE: this component should NOT be used in spectrum-free components like merch-card\n\nimport { LitElement, html } from 'lit';\n\nimport { styles } from './merch-secure-transaction.css.js';\n\nconst TAG_NAME = 'merch-secure-transaction';\n\nexport default class SecureTransaction extends LitElement {\n    static properties = {\n        labelText: { attribute: 'label', type: String },\n        showIcon: { attribute: 'icon', type: Boolean },\n        tooltipText: { attribute: 'tooltip', type: String },\n    };\n\n    static styles = [styles];\n\n    labelText = '';\n    showIcon = true;\n    tooltipText = '';\n\n    render() {\n        const { labelText, showIcon, tooltipText } = this;\n\n        const label = html`\n            <div class=\"${showIcon ? 'icon' : ''}\" id=\"label\" slot=\"trigger\">\n                ${labelText}\n            </div>\n        `;\n\n        if (!tooltipText) return label;\n\n        return html`\n            <overlay-trigger placement=\"top-start\" offset=\"4\">\n                ${label}\n                <sp-tooltip id=\"tooltip\" slot=\"hover-content\" delayed\n                    >${tooltipText}</sp-tooltip\n                >\n            </overlay-trigger>\n        `;\n    }\n}\n\nwindow.customElements.define(TAG_NAME, SecureTransaction);\n", "import { css } from 'lit';\n// TODO: a11y, r12s (responsiveness, if needed)\nimport { DESKTOP_UP, TABLET_UP } from './media.js';\n\nexport const styles = css`\n    #label {\n        align-items: center;\n        cursor: pointer;\n        display: inline-flex;\n        gap: var(--consonant-merch-spacing-xxxs);\n        white-space: nowrap;\n    }\n\n    #label.icon::before {\n        background-position: center;\n        background-size: contain;\n        background: var(--secure-icon) no-repeat;\n        content: '';\n        display: inline-block;\n        height: 1em;\n        width: 1em;\n    }\n`;\n"],
  "mappings": "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",
  "names": ["LitElement", "html", "nothing", "ensureMethod", "value", "type", "fallback", "FocusGroupController", "host", "direction", "elementEnterAction", "elements", "focusInIndex", "isFocusableElement", "listenerScope", "_el", "_elements", "event", "path", "targetIndex", "el", "diff", "currentIndex", "focused", "focusedElement", "moveToNextElement", "options", "focusElement", "offset", "element", "length", "steps", "nextIndex", "relatedTarget", "code", "RovingTabindexController", "FocusGroupController", "focused", "offset", "el", "getTabIndex", "tabIndex", "removeTabIndex", "updatable", "NAMESPACE", "CLASS_NAME_HIDDEN", "EVENT_TYPE_READY", "TAG_NAME_SERVICE", "dispatchAsyncEvent", "target", "type", "bubbles", "cancelable", "composed", "detail", "getCommonAncestor", "elements", "first", "rest", "ancestor", "element", "isRegularPrice", "placeholder", "template", "joinTokens", "tokens", "delimiter", "token", "index", "NAMESPACE", "makeCssClassName", "args", "makeEventTypeName", "showOffers", "offers", "filter", "i", "offer", "CLASS_NAME_HIDDEN", "FAILED", "PENDING", "RESOLVED", "AsyncControl", "#detail", "#options", "#state", "#target", "target", "cssPrefix", "eventOptions", "eventPrefix", "options", "state", "makeCssClassName", "makeEventTypeName", "#notify", "detail", "cssClassNames", "eventTypeNames", "key", "dispatchAsyncEvent", "resolve", "reject", "error", "value", "resolved", "failed", "once", "onFailed", "event", "onResolved", "UNKNOWN_PLAN_TYPE", "makeOffers", "container", "filters", "placeholders", "offers", "placeholder", "i", "wcsOffers", "planType", "group", "checkoutLinks", "inlinePrices", "candidate", "getCommonAncestor", "offer", "discoverService", "callback", "once", "head", "latest", "discover", "current", "TAG_NAME_SERVICE", "EVENT_TYPE_READY", "CommerceAware", "Component", "tagName", "#control", "AsyncControl", "#commerce", "#dispose", "#log", "#offers", "#preselected", "#selected", "#updateSelected", "value", "selected", "old", "commerce", "index", "CheckoutLink", "InlinePrice", "error", "css", "styles", "LitElement", "html", "css", "styles", "css", "TAG_NAME", "SecureTransaction", "LitElement", "styles", "labelText", "showIcon", "tooltipText", "label", "html", "SLOT_COMMITMENT", "SLOT_CONDITION", "SLOT_CONDITION_TOOLTIP", "SLOT_FOOTER", "SLOT_HEADER", "SLOT_OFFER", "SLOT_STOCK", "OFFER_SLOTS", "REACTIONS", "TAG_NAME", "TAG_NAME_STOCK", "SubscriptionPanel", "CommerceAware", "LitElement", "#active", "#card", "#checkout", "#rovingTabindex", "RovingTabindexController", "#stock", "#stockSelected", "#updateCheckout", "checkout", "selected", "CLASS_NAME_HIDDEN", "options", "isRegularPrice", "stock", "regularPrice", "#updateSelected", "radio", "showOffers", "offer", "#updateOffers", "offers", "_", "index", "template", "slotName", "#updateSlot", "container", "name", "elements", "clone", "element", "card", "value", "planType", "onInputChange", "html", "nothing", "onStockClick", "old", "onFooterSlotChange", "slot", "changed", "commerce", "log", "key", "args", "styles"]
}
